/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { createHandlerBoundToURL, precacheAndRoute, matchPrecache } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";
import { setCatchHandler } from "workbox-routing";
import { Workbox } from "workbox-window";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
 // Return false to exempt requests from being fulfilled by index.html.
 ({ request, url }: { request: Request; url: URL }) => {
  // If this isn't a navigation, skip.
  if (request.mode !== "navigate") {
   return false;
  }

  // If this is a URL that starts with /_, skip.
  if (url.pathname.startsWith("/_")) {
   return false;
  }

  // If this looks like a URL for a resource, because it contains
  // a file extension, skip.
  if (url.pathname.match(fileExtensionRegexp)) {
   return false;
  }

  // Return true to signal that we want to use the handler.
  return true;
 },
 createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
 // Add in any other file extensions or routing criteria as needed.
 ({ url }) => url.origin === self.location.origin && url.pathname.endsWith(".png"),
 // Customize this strategy as needed, e.g., by changing to CacheFirst.
 new StaleWhileRevalidate({
  cacheName: "images",
  plugins: [
   // Ensure that once this runtime cache reaches a maximum size the
   // least-recently used images are removed.
   new ExpirationPlugin({ maxEntries: 50 }),
  ],
 })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
 if (event.data && event.data.type === "SKIP_WAITING") {
  self.skipWaiting();
 }
});

// Any other custom service worker logic can go here.

self.addEventListener("install", (event) => {
 // forces a service worker to activate immediately (forces update)
 self.skipWaiting();
});

// Перехватываем ошибки, связанные с маршрутизацией, такие как отсутствие подключения к сети
//@ts-ignore
setCatchHandler(async ({ event }) => {
 // Возвращаем предварительно сохраненную резервную страницу при запросе “документа”
 //@ts-ignore
 if (event.request.destination === "document") {
  return matchPrecache("/offline.html");
 }

 return Response.error();
});

if ("serviceWorker" in navigator) {
 const wb = new Workbox("/sw.js");
 let registration;

 const showSkipWaitingPrompt = (event: any) => {
  // `event.wasWaitingBeforeRegister` будет иметь значение `false`, если это
  // первый раз, когда обновленный СВ находится в режиме ожидания.
  // Когда `event.wasWaitingBeforeRegister` имеет значение `true`, предыдущий
  // обновленный СВ все еще находится в режиме ожидания.
  // Это позволяет кастомизировать UI.

  // Предположим, что приложение имеет несколько элементов UI,
  // которые пользователь может принять или отклонить
  const prompt = createUIPrompt({
   onAccept: () => {
    // Допустим, пользователь принял обновление, регистрируем обработчик,
    // который перезагрузит страницу как только предыдущий ожидающий
    // СВ получит контроль над ней
    wb.addEventListener("controlling", (event) => {
     window.location.reload();
    });

    wb.messageSkipWaiting();
   },

   onReject: () => {
    prompt.dismiss();
   },
  });
 };

 // Регистрируем обработчик, который определяет момент, когда
 // СВ был установлен, но ожидает активации
 wb.addEventListener("waiting", showSkipWaitingPrompt);

 wb.register();
}
